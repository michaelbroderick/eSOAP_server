"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoiPasswordComplexity = void 0;
const Joi = __importStar(require("joi"));
exports.JoiPasswordComplexity = Joi.extend((joi) => {
    return {
        type: "string",
        base: joi.string(),
        messages: {
            "password.minOfUppercase": "should contain at least {#min} uppercase character",
            "password.minOfSpecialCharacters": "should contain at least {#min} special character",
            "password.minOfLowercase": "should contain at least {#min} lowercase character",
            "password.minOfNumeric": "should contain at least {#min} numeric character",
        },
        rules: {
            minOfUppercase: {
                method(min) {
                    return this.$_addRule({
                        name: "minOfUppercase",
                        args: { min },
                    });
                },
                args: [
                    {
                        name: "min",
                        assert: (value) => typeof value === "number" && !isNaN(value),
                        message: "must be a number",
                    },
                ],
                validate: (value, helpers, { min = 0 }) => {
                    const numUpper = (value.match(/[A-Z]/g) || []).length;
                    if (numUpper < min)
                        return helpers.error("password.minOfUppercase", { min });
                    return value;
                },
            },
            minOfLowercase: {
                method(min) {
                    return this.$_addRule({
                        name: "minOfLowercase",
                        args: { min },
                    });
                },
                args: [
                    {
                        name: "min",
                        assert: (value) => typeof value === "number" && !isNaN(value),
                        message: "must be a number",
                    },
                ],
                validate: (value, helpers, { min = 0 }) => {
                    const numUpper = (value.match(/[a-z]/g) || []).length;
                    if (numUpper < min)
                        return helpers.error("password.minOfLowercase", { min });
                    return value;
                },
            },
            minOfSpecialCharacters: {
                method(min) {
                    return this.$_addRule({
                        name: "minOfSpecialCharacters",
                        args: { min },
                    });
                },
                args: [
                    {
                        name: "min",
                        assert: (value) => typeof value === "number" && !isNaN(value),
                        message: "must be a number",
                    },
                ],
                validate: (value, helpers, { min = 0 }) => {
                    const numUpper = value.length - (value.match(/[a-zA-Z0-9]/g) || []).length;
                    if (numUpper < min)
                        return helpers.error("password.minOfSpecialCharacters", { min });
                    return value;
                },
            },
            minOfNumeric: {
                method(min) {
                    return this.$_addRule({
                        name: "minOfNumeric",
                        args: { min },
                    });
                },
                args: [
                    {
                        name: "min",
                        assert: (value) => typeof value === "number" && !isNaN(value),
                        message: "must be a number",
                    },
                ],
                validate: (value, helpers, { min = 0 }) => {
                    const numUpper = (value.match(/[0-9]/g) || []).length;
                    if (numUpper < min)
                        return helpers.error("password.minOfNumeric", { min });
                    return value;
                },
            },
        },
    };
});
